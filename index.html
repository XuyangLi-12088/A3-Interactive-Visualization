<!doctype html>
<meta charset="utf-8" />
<title>US Age-Adjusted Death Rates — D3 (Choropleth + Trend, Robust)</title>
<style>
  body { margin: 20px; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  .layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
  .zoom-controls { display: flex; gap: 8px; margin-top: 8px; }
  .zoom-btn { padding: 4px 12px; border: 1px solid #ccc; border-radius: 6px; background: #f7f7f7; cursor: pointer; font-size: 12px; }
  .zoom-btn:hover { background: #eee; }
  .trend-container { position: relative; }
  .panel { border: 1px solid #ddd; border-radius: 10px; padding: 14px; }
  .title { font-weight: 700; margin: 0 0 8px; }
  .subtle { color: #666; font-size: 12px; }
  .controls { display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:10px; }
  svg { display: block; }
  .state { stroke: #fff; stroke-width: 1; cursor: pointer; }
  .state.selected { stroke: #222; stroke-width: 2; }
  .legend { display:flex; align-items:center; gap:8px; margin-top:8px; }
  .tooltip {
    position: absolute; pointer-events: none; background: rgba(0,0,0,.75);
    color: #fff; font-size: 12px; padding: 6px 8px; border-radius: 6px;
    transform: translate(-50%, -120%); white-space: nowrap;
  }
  .btn { padding:4px 8px; border:1px solid #ccc; border-radius:6px; background:#f7f7f7; cursor:pointer; }
  .btn:hover { background:#eee; }
</style>

<div class="panel">
  <div class="title">Controls</div>
  <div class="controls">
    <label>Cause: <select id="cause"></select></label>
    <label>Year: <input id="year" type="range" min="1999" max="2017" value="2017" step="1"></label>
    <span id="yearVal" style="min-width:40px;display:inline-block;text-align:right">2017</span>
    <button id="reset" class="btn">Reset</button>
    <span id="status" class="subtle"></span>
  </div>
  <div class="subtle">
    Age-adjusted death rates (per 100,000) for the 10 leading causes of death in the U.S., 1999–present.
    Rates are age-adjusted to the 2000 U.S. standard population (NCHS/CDC).
  </div>
</div>

<div class="layout">
  <div class="panel">
    <div class="title">US Map — Age-adjusted Death Rate per 100,000</div>
    <svg id="map" width="100%" height="500" viewBox="0 0 760 500" preserveAspectRatio="xMidYMid meet"></svg>
    <div class="legend">
      <span class="subtle">Lower</span>
      <svg id="legend" width="260" height="46"></svg>
      <span class="subtle">Higher</span>
    </div>
    <div class="subtle">Hover a state for details. Click a state to see its last-10-year trend (right).</div>
  </div>

  <div class="panel">
    <div class="title">Trend — All Causes (1999-2017)</div>
    <div class="trend-container">
      <svg id="trend" width="100%" height="500" viewBox="0 0 700 500" preserveAspectRatio="xMidYMid meet"></svg>
      <div class="zoom-controls">
        <button id="zoomIn" class="zoom-btn">Zoom In</button>
        <button id="zoomOut" class="zoom-btn">Zoom Out</button>
        <button id="zoomReset" class="zoom-btn">Reset Zoom</button>
        <span class="subtle" style="margin-left: 8px;">Scroll or drag to zoom/pan</span>
      </div>
    </div>
    <div class="subtle" id="trendLabel"></div>
    <div id="trendLegend" style="margin-top: 10px;"></div>
  </div>
</div>

<div id="tooltip" class="tooltip" style="opacity:0"></div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson-client@3"></script>
<script>
const CSV_FILE = "NCHS_-_Leading_Causes_of_Death__United_States.csv";
const TOPO_URL = "https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json";

const FIPS_TO_NAME = new Map([
  ["01","Alabama"],["02","Alaska"],["04","Arizona"],["05","Arkansas"],["06","California"],
  ["08","Colorado"],["09","Connecticut"],["10","Delaware"],["11","District of Columbia"],["12","Florida"],
  ["13","Georgia"],["15","Hawaii"],["16","Idaho"],["17","Illinois"],["18","Indiana"],
  ["19","Iowa"],["20","Kansas"],["21","Kentucky"],["22","Louisiana"],["23","Maine"],
  ["24","Maryland"],["25","Massachusetts"],["26","Michigan"],["27","Minnesota"],["28","Mississippi"],
  ["29","Missouri"],["30","Montana"],["31","Nebraska"],["32","Nevada"],["33","New Hampshire"],
  ["34","New Jersey"],["35","New Mexico"],["36","New York"],["37","North Carolina"],["38","North Dakota"],
  ["39","Ohio"],["40","Oklahoma"],["41","Oregon"],["42","Pennsylvania"],["44","Rhode Island"],
  ["45","South Carolina"],["46","South Dakota"],["47","Tennessee"],["48","Texas"],["49","Utah"],
  ["50","Vermont"],["51","Virginia"],["53","Washington"],["54","West Virginia"],["55","Wisconsin"],["56","Wyoming"]
]);


function canon(s) {
  return String(s ?? "")
    .replace(/\u00A0/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

function stateNameOf(feature) {
  const p = feature.properties || {};
  if (p.name) return canon(p.name);
  const fips = String(feature.id).padStart(2, "0");
  return canon(FIPS_TO_NAME.get(fips) || "");
}

const appState = { cause:null, year:2017, selectedName:"United States" };
const causeSel  = d3.select("#cause");
const yearInput = d3.select("#year");
const yearVal   = d3.select("#yearVal");
const statusEl  = d3.select("#status");
const tip       = d3.select("#tooltip");

const mapSVG   = d3.select("#map");
const legendSVG= d3.select("#legend");
const trendSVG = d3.select("#trend");

// Map projection - use viewBox dimensions
const mapW = 760, mapH = 500;
const proj = d3.geoAlbersUsa().translate([mapW/2, mapH/2]).scale(950);
const geoPath = d3.geoPath(proj);

// Trend chart scales - use viewBox dimensions
const trW = 700, trH = 500;
const trM = {t:20,r:20,b:32,l:44};
const x = d3.scaleLinear().range([trM.l, trW - trM.r]);
const y = d3.scaleLinear().range([trH - trM.b, trM.t]);

// Store original domains for zoom reset
let xOriginalDomain = [0, 1];
let yOriginalDomain = [0, 1];

// Create clip path for zooming
trendSVG.append("defs").append("clipPath")
  .attr("id", "trend-clip")
  .append("rect")
  .attr("x", trM.l)
  .attr("y", trM.t)
  .attr("width", trW - trM.l - trM.r)
  .attr("height", trH - trM.t - trM.b);

trendSVG.append("g").attr("class","x-axis").attr("transform",`translate(0,${trH-trM.b})`);
trendSVG.append("g").attr("class","y-axis").attr("transform",`translate(${trM.l},0)`);

// Create zoom container
const zoomContainer = trendSVG.append("g").attr("class", "zoom-container").attr("clip-path", "url(#trend-clip)");

// Create a background rect for zoom area
const zoomBackground = trendSVG.append("rect")
  .attr("class", "zoom-background")
  .attr("x", trM.l)
  .attr("y", trM.t)
  .attr("width", trW - trM.l - trM.r)
  .attr("height", trH - trM.t - trM.b)
  .style("fill", "transparent")
  .style("cursor", "grab")
  .style("pointer-events", "all")
  .on("mousedown", function() {
    d3.select(this).style("cursor", "grabbing");
  })
  .on("mouseup", function() {
    d3.select(this).style("cursor", "grab");
  })
  .on("mouseleave", function() {
    d3.select(this).style("cursor", "grab");
  });

// Zoom behavior
let zoom = null;

// Color scheme for causes (10 distinct colors)
const causeColors = d3.scaleOrdinal()
  .range([
    "#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd",
    "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"
  ]);

// Color scale
const color = d3.scaleSequential(d3.interpolateYlOrRd);

Promise.all([
  d3.csv(CSV_FILE, d3.autoType),
  d3.json(TOPO_URL)
]).then(([raw, topo]) => {
  const data = raw.map(d => ({
    year : +d["Year"],
    cause: canon(d["Cause Name"] ?? d["Cause name"] ?? d["Cause Name"]),
    name : canon(d["State"]),
    rate : +d["Age-adjusted Death Rate"]
  })).filter(d =>
    Number.isFinite(d.year) &&
    Number.isFinite(d.rate) &&
    d.cause.length && d.name.length
  );

  // Years & causes
  const years  = Array.from(new Set(data.map(d=>d.year))).sort((a,b)=>a-b);
  const causes = Array.from(new Set(data.map(d=>d.cause))).sort();

  // Initialize cause color scale
  causeColors.domain(causes);

  yearInput.attr("min", d3.min(years)).attr("max", d3.max(years)).attr("value", d3.max(years));
  yearVal.text(d3.max(years));
  appState.year = d3.max(years);

  causeSel.selectAll("option").data(causes).join("option")
    .attr("value", d=>d).text(d=>d);
  appState.cause = causes[0];
  causeSel.property("value", appState.cause);

  // Build lookups
  const byCauseYearName = d3.rollup(
    data,
    v => new Map(v.map(r => [canon(r.name), r.rate])),
    d => d.cause, d => d.year
  );
  const byCauseNameSeries = d3.rollup(
    data.sort((a,b)=>d3.ascending(a.year,b.year)),
    v => v.map(({year,rate}) => ({year,rate})),
    d => d.cause, d => canon(d.name)
  );

  const allFeatures = topojson.feature(topo, topo.objects.states).features;
  const states = allFeatures.filter(f => {
    const fips = String(f.id).padStart(2, "0");
    return ["60","66","69","72","78"].includes(fips) ? false : true;
  });
  const borders = topojson.mesh(topo, topo.objects.states, (a,b)=>a!==b);
  const totalStates = states.length;

  // Initialize zoom behavior after data is loaded
  zoom = d3.zoom()
    .scaleExtent([0.5, 10])
    .extent([[trM.l, trM.t], [trW - trM.r, trH - trM.b]])
    .on("zoom", (event) => {
      if (!xOriginalDomain || !yOriginalDomain || xOriginalDomain.length < 2 || yOriginalDomain.length < 2) return;
      
      const {transform} = event;
      const xScale = d3.scaleLinear().domain(xOriginalDomain).range([trM.l, trW - trM.r]);
      const yScale = d3.scaleLinear().domain(yOriginalDomain).range([trH - trM.b, trM.t]);
      
      x.domain(transform.rescaleX(xScale).domain());
      y.domain(transform.rescaleY(yScale).domain());
      updateTrendAxes();
      updateTrendPaths();
    });

  // Apply zoom to the background rect
  zoomBackground.call(zoom);

  function drawLegend(lo, hi) {
    legendSVG.selectAll("*").remove();
    const w = +legendSVG.attr("width");
    const m = {l:10, r:10, t:8, b:28};
    const g = legendSVG.append("g").attr("transform",`translate(${m.l},${m.t})`);
    const gradId = "grad-"+Math.random().toString(36).slice(2);
    const defs = legendSVG.append("defs");
    const grad = defs.append("linearGradient").attr("id", gradId)
      .attr("x1","0%").attr("x2","100%").attr("y1","0%").attr("y2","0%");
    for (let t=0;t<=1.0001;t+=0.1) {
      grad.append("stop")
        .attr("offset", `${t*100}%`)
        .attr("stop-color", color(lo + t*(hi-lo)));
    }
    g.append("rect").attr("width", w-m.l-m.r).attr("height", 10).attr("fill", `url(#${gradId})`);
    const ax = d3.axisBottom(d3.scaleLinear().domain([lo,hi]).range([0, w-m.l-m.r])).ticks(5);
    g.append("g").attr("transform",`translate(0,10)`).call(ax);
  }

  function renderMap() {
    const rates = byCauseYearName.get(appState.cause)?.get(appState.year) || new Map();

    const vals = states.map(f => rates.get(stateNameOf(f))).filter(v => Number.isFinite(v) && v >= 0);

    const matched = states.filter(f => Number.isFinite(rates.get(stateNameOf(f)))).length;

    let lo = 0, hi = 100;
    if (vals.length) {
      const sorted = vals.slice().sort(d3.ascending);
      lo = d3.quantileSorted(sorted, 0.02) ?? d3.min(sorted);
      hi = d3.quantileSorted(sorted, 0.98) ?? d3.max(sorted);
      if (!(Number.isFinite(lo) && Number.isFinite(hi) && hi > lo)) {
        lo = d3.min(sorted); hi = d3.max(sorted);
      }
    }
    color.domain([lo, hi]);
    drawLegend(lo, hi);

    statusEl.html(
      `Year ${appState.year} &nbsp;•&nbsp; 
      Cause: <b>${appState.cause}</b> &nbsp;•&nbsp; 
      Selected: <b>${appState.selectedName}</b>`
    );


    const g = mapSVG.selectAll("g.map").data([null]).join("g").attr("class","map");

    const paths = g.selectAll("path.state").data(states, d => d.id);
    paths.join(
      enter => enter.append("path").attr("class","state")
        .attr("d", geoPath)
        .style("fill", d => {
          const v = rates.get(stateNameOf(d));
          return Number.isFinite(v) ? color(v) : "#eee";
        })
        .on("mousemove", (event, d) => {
          const nm = stateNameOf(d);
          // Get current rates based on current appState, not the captured rates variable
          const currentRates = byCauseYearName.get(appState.cause)?.get(appState.year) || new Map();
          const v = currentRates.get(nm);
          tip.style("opacity", 1)
             .html(`<b>${nm}</b><br>${appState.cause}<br>Rate: <b>${Number.isFinite(v)?v.toFixed(1):"N/A"}</b>`)
             .style("left", (event.pageX) + "px")
             .style("top", (event.pageY - 10) + "px");
        })
        .on("mouseout", () => tip.style("opacity", 0))
        .on("click", (event, d) => {
          appState.selectedName = stateNameOf(d);
          renderTrend();
          renderMap();
        }),
      update => update.transition().duration(400)
        .style("fill", d => {
          const v = rates.get(stateNameOf(d));
          return Number.isFinite(v) ? color(v) : "#eee";
        })
    );

    // selected outline
    mapSVG.selectAll("path.state")
      .classed("selected", d => stateNameOf(d) === appState.selectedName);

    // hairline borders
    const border = mapSVG.selectAll("path.border").data([borders]);
    border.join(
      enter => enter.append("path").attr("class","border").attr("d", geoPath)
        .attr("fill","none").attr("stroke","#fff").attr("stroke-width",1)
    );
  }

  let allSeriesData = [];

  function updateTrendAxes() {
    trendSVG.select(".x-axis").transition().duration(200)
      .call(d3.axisBottom(x).ticks(Math.min(20, Math.ceil((x.domain()[1] - x.domain()[0])))).tickFormat(d3.format("d")));
    trendSVG.select(".y-axis").transition().duration(200)
      .call(d3.axisLeft(y));
  }

  function updateTrendPaths() {
    if (!allSeriesData || allSeriesData.length === 0) return;

    const line = d3.line().defined(d => Number.isFinite(d.rate) && Number.isFinite(d.year))
      .x(d => x(d.year)).y(d => y(d.rate));

    // Update series groups
    const seriesG = zoomContainer.selectAll("g.series")
      .data(allSeriesData, d => d.cause)
      .join(
        enter => enter.append("g").attr("class", "series"),
        update => update,
        exit => exit.remove()
      );

    // Update paths - highlight selected cause
    seriesG.selectAll("path.line")
      .data(d => [d], d => d.cause)
      .join(
        enter => enter.append("path")
          .attr("class", "line")
          .attr("fill", "none")
          .attr("stroke", d => causeColors(d.cause))
          .attr("stroke-width", d => d.cause === appState.cause ? 4 : 2)
          .attr("opacity", d => d.cause === appState.cause ? 1 : 0.4)
          .attr("d", d => line(d.data)),
        update => update.transition().duration(200)
          .attr("d", d => line(d.data))
          .attr("stroke-width", d => d.cause === appState.cause ? 4 : 2)
          .attr("opacity", d => d.cause === appState.cause ? 1 : 0.4),
        exit => exit.remove()
      );

    // Update points - highlight selected cause
    seriesG.selectAll("circle.pt")
      .data(d => d.data.map(point => ({ ...point, cause: d.cause })), d => `${d.cause}-${d.year}`)
      .join(
        enter => enter.append("circle")
          .attr("class", "pt")
          .attr("r", d => d.cause === appState.cause ? 4 : 3)
          .attr("fill", d => causeColors(d.cause))
          .attr("opacity", d => d.cause === appState.cause ? 1 : 0.4)
          .attr("cx", d => x(d.year))
          .attr("cy", d => y(d.rate))
          .append("title")
            .text(d => `${d.cause} — ${d.year}: ${d.rate.toFixed(1)}`),
        update => update.transition().duration(200)
          .attr("cx", d => x(d.year))
          .attr("cy", d => y(d.rate))
          .attr("r", d => d.cause === appState.cause ? 4 : 3)
          .attr("opacity", d => d.cause === appState.cause ? 1 : 0.4),
        exit => exit.remove()
      );
  }

  function highlightCause() {
    // Update line styles based on selected cause
    zoomContainer.selectAll("g.series").each(function(seriesData) {
      const isHighlighted = seriesData.cause === appState.cause;
      d3.select(this).selectAll("path.line")
        .transition().duration(200)
        .attr("stroke-width", isHighlighted ? 4 : 2)
        .attr("opacity", isHighlighted ? 1 : 0.4);

      d3.select(this).selectAll("circle.pt")
        .transition().duration(200)
        .attr("r", isHighlighted ? 4 : 3)
        .attr("opacity", isHighlighted ? 1 : 0.4);
    });

    // Update legend styles based on selected cause
    d3.select("#trendLegend").selectAll(".legend-item").each(function() {
      const cause = d3.select(this).attr("data-cause");
      const isHighlighted = cause === appState.cause;
      d3.select(this)
        .transition().duration(200)
        .style("font-weight", isHighlighted ? "bold" : "normal")
        .style("opacity", isHighlighted ? 1 : 0.4);
      
      d3.select(this).select(".legend-line")
        .transition().duration(200)
        .style("width", isHighlighted ? "20px" : "16px")
        .style("height", isHighlighted ? "4px" : "3px");
    });

    // Update trend label to show highlighted cause
    const yStart = d3.min(years);
    const yEnd = d3.max(years);
    d3.select("#trendLabel").text(`${appState.selectedName} — ${appState.cause} (Years ${yStart}–${yEnd})`);
  }

  function renderTrend() {
    const yStart = d3.min(years);
    const yEnd = d3.max(years);

    const chosen = appState.selectedName;
    
    // Get data for all causes for the selected state/region
    allSeriesData = [];
    causes.forEach(cause => {
      const seriesMap = byCauseNameSeries.get(cause) || new Map();
      const full = seriesMap.get(canon(chosen)) || [];
      const filtered = full.filter(d => d.year >= yStart && d.year <= yEnd);
      if (filtered.length > 0) {
        allSeriesData.push({ cause, data: filtered });
      }
    });

    // Set original domains
    xOriginalDomain = [yStart - 0.3, yEnd + 0.3];
    
    // Find max rate across all causes
    let ymax = 1;
    allSeriesData.forEach(s => {
      const max = d3.max(s.data, d => d.rate) ?? 0;
      if (max > ymax) ymax = max;
    });
    const yDomain = d3.scaleLinear().domain([0, ymax]).nice();
    yOriginalDomain = yDomain.domain();

    // Set initial domains
    x.domain(xOriginalDomain);
    y.domain(yOriginalDomain);

    // Update paths first with initial domains
    updateTrendAxes();
    updateTrendPaths();

    // Reset zoom after data is rendered
    if (zoom) {
      zoomBackground.call(zoom.transform, d3.zoomIdentity);
    }

    d3.select("#trendLabel").text(`${appState.selectedName} — ${appState.cause} (Years ${yStart}–${yEnd})`);

    // Render legend
    const legendEl = d3.select("#trendLegend");
    legendEl.selectAll("*").remove();
    const legend = legendEl.append("div")
      .style("display", "flex")
      .style("flex-wrap", "wrap")
      .style("gap", "12px")
      .style("font-size", "11px");

    causes.forEach(cause => {
      const isHighlighted = cause === appState.cause;
      const item = legend.append("div")
        .attr("class", "legend-item")
        .attr("data-cause", cause)
        .style("display", "flex")
        .style("align-items", "center")
        .style("gap", "6px")
        .style("font-weight", isHighlighted ? "bold" : "normal")
        .style("opacity", isHighlighted ? 1 : 0.4);
      item.append("span")
        .attr("class", "legend-line")
        .style("display", "inline-block")
        .style("width", isHighlighted ? "20px" : "16px")
        .style("height", isHighlighted ? "4px" : "3px")
        .style("background-color", causeColors(cause));
      item.append("span")
        .attr("class", "legend-text")
        .text(cause);
    });
  }

      causeSel.on("change", () => {
        appState.cause = causeSel.property("value");
        renderMap();
        highlightCause(); // Update trend chart highlighting
      });
      yearInput.on("input", () => {
        appState.year = +yearInput.property("value");
        yearVal.text(appState.year);
        renderMap(); renderTrend();
      });
      d3.select("#reset").on("click", () => {
        appState.cause = causes[0]; causeSel.property("value", appState.cause);
        appState.year  = d3.max(years); yearInput.property("value", appState.year); yearVal.text(appState.year);
        appState.selectedName = "United States";
        renderMap(); renderTrend();
      });

      // Zoom controls
      d3.select("#zoomIn").on("click", (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (zoom && xOriginalDomain && yOriginalDomain && xOriginalDomain.length >= 2 && yOriginalDomain.length >= 2) {
          const node = zoomBackground.node();
          if (node) {
            const currentTransform = d3.zoomTransform(node) || d3.zoomIdentity;
            const newTransform = currentTransform.scale(1.5);
            zoomBackground.transition().duration(300).call(zoom.transform, newTransform);
          }
        }
      });
      d3.select("#zoomOut").on("click", (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (zoom && xOriginalDomain && yOriginalDomain && xOriginalDomain.length >= 2 && yOriginalDomain.length >= 2) {
          const node = zoomBackground.node();
          if (node) {
            const currentTransform = d3.zoomTransform(node) || d3.zoomIdentity;
            const newTransform = currentTransform.scale(1/1.5);
            zoomBackground.transition().duration(300).call(zoom.transform, newTransform);
          }
        }
      });
      d3.select("#zoomReset").on("click", (event) => {
        event.stopPropagation();
        event.preventDefault();
        if (zoom && xOriginalDomain && yOriginalDomain && xOriginalDomain.length >= 2 && yOriginalDomain.length >= 2) {
          zoomBackground.transition().duration(300).call(zoom.transform, d3.zoomIdentity);
        }
      });

  renderMap(); renderTrend();
});
</script>
